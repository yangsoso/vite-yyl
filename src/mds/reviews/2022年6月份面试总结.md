## JavaScript 基础

### 闭包的理解、应用、优缺点
    理解: 由函数以及声明该函数的词法环境组合而成的。该环境包含了这个闭包创建时作用域内的任何局部变量。
    表现为： 就是可以在一个内层函数中访问到其外层函数的作用域。当创建一个函数的时候，闭包就会在创建函数的同时被创建出来

    应用场景：封转私有变量或函数、函数柯里化、模仿块级作用域、实现数据缓存、防抖节流等

    缺点：
        闭包产生的参数和变量不会被垃圾回收机制回收，容易造成内存泄露，通常使用完之后将变量设置为null
        有一定的性能损耗

### 原型、原型链的理解
原型：
1. 所有引用类型(函数、数组、对象、正则)都有一个 __proto__(隐式原型) 属性，属性值是一个普通的对象
2. 所有函数都有一个 prototype(显示原型) 属性，属性值是一个普通的对象
3. 所有引用类型实例的 __proto__ 属性指向它构造函数的prototype

原型链：
当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，
如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链，尽头是 Object.prototype

**函数在js中，也是一个特殊的对象**
> 原型对象：拥有prototype(显示原型)的对象。在定义函数时就被创建。用来存放实例对象的公有属性和公共方法的一个公共对象，所有原型对象都是Object()的实例
> 在js中，每一个函数类型的数据，都有一个叫做prototype的属性，这个属性指向的是一个对象，就是所谓的原型对象

关系：构造函数-> 通过 new 创建一个实例 -> 实例对象的隐式原型__proto__ -> 构造函数的 prototype(原型)

Person.prototype
```
 function Person() {
    this.name = 'john';
    this.say = function(){
        console.log(this.name);
    }
}
```
对于原型对象来说，它有个constructor属性，指向它的构造函数
Person.prototype.constructor = person()
    
### 如何实现函数的继承各个方式的优缺点
 1. 原型链继承. 使用 new 让新实例的原型等于父类的实例
 `function Child() {}; Child.prototype = new Person(); let child = new Child()`
 2. 构造函数实现继承： 用.call()和.apply()将父类构造函数引入子类函数(在子类函数中做了父类函数的自执行(复制))
 `function Child(name) { Person.call(this,name); };let child1 = new Child('xie')`
 3. 组合继承（组合原型链继承和借用构造函数继承）
 `function Child(name) {Person.call(this, name);}Child.prototype = new Person();let child3 = new Child('ting')`
 4. 原型式继承
 5. 寄生式继承
 6. 寄生组合式继承


### JS 作用域 笔试题
1. 除了函数外，js是没有块级作用域
2. 作用域链： 内部可以访问外部的变量，但是外部不能访问内部的变量
注意：内部有，优先查找内部，如果内部没有就查找外部的

3. 注意声明的变量是用var 还是没有写
4. js有变量和函数提升的机制【变量悬挂声明】
5.  优先级： 声明变量-> 声明普通函数-> 参数 -> 变量提升

### Map Set Object 的用法和区别
    JavaScript 的对象 Object，本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制.
    Map 键值对结构，和 JSON 对象类似; key 可以是字符串或对象的任意类型, 完善 Object 的 key 只能是字符串的缺憾。
    Set 值就是键，不能通过迭代器来改变 Set 的值
    区别
    Object 是 字符串-值 的对应，Map 是 值-值 的对应。
    Map 和 Set 都具有极快的查找速度
    初始化的值不一样，Map 需要一个二位数组，而 Set 需要的是一维 Array 数组
    Map 和 Set 都不允许健重复

### 深拷贝和浅拷贝
    深拷贝和浅拷贝最根本的区别在于是否真正获取看一个对象的复制实体，而不是引用。
    深拷贝的方法:
    - JSON.parse(JSON.stringIfy()) 
**这种方式无法正确处理函数、正则、undefined、Symbol，会丢失掉这部分的数据。**
    - 用递归去复制所有层级属性
    - 通过jQuery的$.extend(true,[],obj)

    浅拷贝的方式：
    Object.assign()、扩展运算符、Array.prototype.slice() 、Array.prototype.concat()

### 节流和防抖
    在前端开发过程中，我们经常会需要绑定一些持续触发的事件，如:resize，scroll，mousermove。但是有些时候我们并不想在事件持续触发的过程中那么频繁的去执行事件回调函数。所有我们就需要节流和防抖。
    节流就是指，在事件持续触发的过程中，我们设置一个定时器，在规定的时间触发一次回调函数。
    防抖就是指，我们设置一个计时器，在最后一次事件触发后开始计时，时间到了触发一次回调函数，如果时间没到又触发了事件，则将计时器的时间归位，重新计时。
    简单来说:节流是控制频率，防抖是控制次数。

### 什么是微事件，什么是宏事件
    宿主环境提供的叫宏事件，如浏览器或 node。
    语言标准提供的叫微事件，如 ES6。
    宏事件有:setTimeout，setInerval，setImmediate，requestAnimationFrame
    微事件有:Promise，nextTick，MutationObserver


## vue 基础和原理
### Vue2.0 、vue3.0 双向数据绑定原理、区别、优势
    - 直接监听对象，数组的变化，而非属性
    - Proxy 返回一个新的对象，可以只操作新对象达到目的，而 Object.defineProperty 只能遍历对象属性 直接修改

### Object.defineProperty VS Proxy 
   - Object.defineProperty 只能劫持对象的属性，而 Proxy 是直接代理对象
   - Object.defineProperty对新增属性需要手动进行Observe

   - Proxy兼容性差
   
   总结：
    - Object.defineProperty 对数组和对象的表现一致，并非不能监控数组下标的变化，vue2.x中无法通过数组索引来实现响应式数据的自动更新是vue本身的设计导致的，不是 defineProperty 的锅。
    - Object.defineProperty 和 Proxy 本质差别是，defineProperty 只能对属性进行劫持，新增属性需要手动 Observe 的问题。
    - Proxy 作为新标准，浏览器厂商势必会对其进行持续优化，但它的兼容性也是块硬伤，并且目前还没有完整的polyfill方案。

### 组件间的通信
    方法一、props/$emit
    方法二、$emit/$on，这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级
    方法三、vuex
    方法四、$attrs/$listeners
    方法五、provide/inject，Vue2.2.0 新增 API,这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。一言而蔽之:祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。

### 分别简述 computed 和 watch 的区别、使用场景
    computed 内部的函数在调用时不加()
    computed 是依赖 vm 中 data 的属性变化而变化的，也就是说，当 data 中的属性发生改变的时候，当前函数才会执行，data 中的属性没有改变的时候，当前函数不会执行
    computed 中的函数必须用 return 返回。
    在computed 中不要对 data 中的属性进行赋值操作。如果对data中的属性进行赋值操作了，就是 data 中的属性发生改变，从而触发 computed 中的函数，形成死循环了
    
    watch 中的函数名称必须要和data中的属性名一致，因为 watch 是依赖 data 中的属性，当 data 中的属性发生改变的时候，watch 中的函数就会执行
    watch 中的回调函数有两个参数，前者是 newVal，后者是oldVal
    watch 中的回调函数是不需要调用的 可以设置立即执行和深度监听

```
    get curName() {
        return this.name;
    },

    watch: {
        'cityName.name': {
            handler(newName, oldName) {
            // ...
            },
            deep: true,
            immediate: true
        }
    }
```
    使用场景:computed----当一个属性受多个属性影响的时候。watch----当一条数据影响多条数据的时候，使用watch。
    todo 原理

### nextTick() 的原理及使用场景

## 各个框架的理解和对比
### vue 和 react 的区别 说说你的看法
 > react 声明式，高效且灵活的用于构建用户界面的 JavaScript 库，提取代码片段组成 UI 界面
 > vue 是 MVVM 设计模式的框架

 1. 从框架的设计思路上来说：
    react 是 html in javaScript,或者说all in javaScript,所以有JSX语法。
    vue 是吧 HTML CSS JS 组合到一个文件，使用各自的处理方式，自己写了一套模板语法。
 2. 核心思想：
    React 声明式渲染、组件化、单向数据流，setSate 更新data 值后，组件自己处理; differ 是首位是除删除外是固定不动的,然后依次遍历对比。
    vue 核心是只关注试图

 3. 区别：
    - react
    更灵活，有丰富的javaScript库。扩展性好，跨多平台开发（通过react native 实现将react组件模型实现 ios和 android 开发） 
    大型应用一般用 react
    - vue
    易于使用，性能更好，文档社区齐全国内，比较流行

 4. diff算法实现
    react 首位是除删除外的是固定不动的，然后依次遍历对比
    vue 的 compile 阶段的optimize标记了static点，可以减少differ的次数，采用双向遍历

 5. 相同点：
    都使用了 Virtual DOM
    提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件
    将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库

### vue 2.0 和 vue 3.0 的区别
1. 重构数据的双向绑定原理，使用 Proxy 代替 Object.defineProperty
2. 性能的提升
    - diff 算法的优化
        vue2 中的虚拟Dom是进行全量的对比;
        vue3 新增了静态标记(patchFlag),只对比带有 PF 的节点，并且通过 Flag 的信息得到当前节点要比对的内容
    - 静态提升
        vue2 中无论元素是否参与更新，每次都会重新创建，然后再渲染
        vue3 对于不参与更新的元素，会做静态提升，只会被创建一次，再渲染时直接复用即可
    - cacheHandlers 事件侦听器缓存
        vue2 默认情况下onClick会被视为动态绑定, 所以每次都会去追踪它的变化
        vue3 但是因为是同一个函数，所以没有追踪变化, 直接缓存起来复用即可
    - ssr 渲染
        vue2 当有大量静态的内容时候，这些内容会被当做纯字符串推进一个buffer里面， 即使存在动态的绑定，会通过模板插值嵌入进去。这样会比通过虚拟dmo来渲染的快上很多很多
        vue3 当静态内容大到一定量级时候，会用_createStaticVNode方法在客户端去生成一个static node，这些静态node，会被直接innerHtml，就不需要创建对象，然后根据对象渲染
    - 按需加载，体积更小
        Tree-shaking 使编译更友好
    - Compostion API: 组合API/注入API
        vue2 使用起来，开发逻辑分散，维护一个功能
        vue3 setup()函数中维护
    - 自定义渲染API（Custom Renderer API）
        vue2 不支持一套代码多个平台
        vue3 自定义渲染函数
    - vite开发构建工具
        vue2 是使用webpack作为开发构建工具的，npm run dev都要等一会，项目越大等的时间越长
        vue3 是使用vite来做开发构建工具。vite支持浏览器支持import关键字，启动项目时浏览器直接请求路由对应的代码文件，代理服务器针对单个文件进行编译并返回。如果请求的文件里还import了其他文件，同理浏览器继续发请求，代理服务器返回。就这样实现了npm run dev时无需编译，实时请求实时编译
    - 支持TS语法
        vue2 需要借助vue-class-component、vue-property-decorator两个库来增加插入ts的写法
        vue3 defineComponent函数 支持了类型声明和更好的ts开发
3. 生命周期函数名字的定义改变
    除了 created 和 beforeCreate 改成 setup,其他的都加一个on在前面，destroyed改成unMounted
4. 对文件的引用不同
    vue2 中new出的实例对象，所有的东西都在这个vue对象上，这样其实无论你用到还是没用到，都会跑一变
    vue3.0中可以用ES module imports按需引入，如：keep-alive内置组件、v-model指令等
4. 项目的启动
    npm run dev / npm run serve
5. 语法上的区别
    v-model语法糖废弃，改用modelValue
    弃用全局Api new Vue()使用 createApp、弃用作用域插槽 scopedSlots、弃用 $children 改成 $ref、弃用 $on,$once,$off
    全局属性的定义 2.0 挂在vue的原型上，3.0 使用config.globalProperties配置 全局方法全部放到 vue.createApp({})的实例上
    3.0需要手动挂载节点
    this.$nextTick 改成直接调用 nextTick(()=>{})
    template 允许设置 key
    监听数据需要加上deep，否则只能监听到数组整个被替换的变化
    
## CSS5 和 HTML5

### BFC
   > 块级格式化上下文。是一个独立的区域。
   > 作用: 可以清除浮动、避免margin重叠、避免某元素被浮动元素覆盖(避免高度塌陷)、实现灵活健壮的自适应布局(自适应两栏布局)。

   BFC布局规则:
    内部的 box 会在垂直方向上一个接一个的放置。
    Box 垂直方向的距离由 margin 决定，属于同一 BFC 的两个相邻 box 的 margin 会发生重叠。
    每个元素的 margin box 的左边，与包含块 border box 的左边接触
    BFC 区域不会与 float box 重叠
    子元素不会影响到外面的元素，形成一个隔离的容器
    计算 BFC 的高度时，浮动元素也会参与计算
    BFC 布局的都是块级元素

    如何创建 BFC ？
    * 根元素
    * float 的值不是 none
    * overflow 的值不是 visible 
    * position 的值不是 static 或 relative
    * display 的值为 table-cell，table-caption，或 inline-block 中的任意一个
    * contain 的值为 layout，content，paint，或 strict 中的任意一个

    总结：
    BFC 内外互不影响 
    BFC 包含内部的浮动   --解决内部浮动元素导致的塌陷
    BFC 排斥外部的浮动   --BFC 的元素不会和外部的浮动发生重叠
    外边距折叠的计算不能跨域 BFC 的边界 
    兄弟 BFC 元素互不影响 --实现多列布局

    BFC 应用场景
    解决块级元素垂直方向margin重叠
    解决高度塌陷问题
    清除浮动

### IFC
 > 行级格式化上下文
    
   如何触发IFC
    块级元素中仅包含内联级别元素

   IFC布局规则
   * 在一个IFC内，子元素是水平方向横向排列的，并且垂直方向起点为元素顶部
   * 子元素只会计算横向样式空间，【padding、border、margin】，垂直方向样式空间不会被计算，【padding、border、margin】
   * 在垂直方向上，子元素会以不同形式来对齐（vertical-align）
   * 能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的行框（line box）。行框的宽度是由包含块（containing box）和与其中的浮动来决定。
   * IFC中的line box一般左右边贴紧其包含块，但float元素会优先排列。
   * IFC中的line box高度由 CSS 行高计算规则来确定，同个IFC下的多个line box高度可能会不同。
   * 当 inline boxes的总宽度少于包含它们的line box时，其水平渲染规则由 text-align 属性值来决定。
   * 当一个inline box超过父元素的宽度时，它会被分割成多个boxes，这些boxes分布在多个line box中。如果子元素未设置强制换行的情况下，inline box将不可被分割，将会溢出父元素。

    IFC 应用场景
    元素水平居中(display: inline-block;; text-align: center;)
    多行文本水平垂直居中(多行文本水平垂直居中display: inline-block;vertical-align: middle;)

### GFC 栅格格式化上下文
 > Grids网格布局

 如何触发GFC？
 当为一个元素设置display值为grid或者inline-grid的时候，此元素将会获得一个独立的渲染区域

 应用场景
 表格，合并，自由拼接，任意魔方布局

### FFC 弹性格式化上下文
> flex布局,弹性盒模型,用作自适应布局比较多
> FFC布局中，float、clear、vertical-align属性不会生效

    如何触发FFC？
    当 display 的值为 flex 或 inline-flex 时，将生成弹性容器（Flex Containers）, 一个弹性容器为其内容建立了一个新的弹性格式化上下文环境（FFC）

    FFC布局规则
    * 设置为 flex 的容器被渲染为一个块级元素
    * 设置为 inline-flex 的容器被渲染为一个行内元素
    * 弹性容器中的每一个子元素都是一个弹性项目。弹性项目可以是任意数量的。弹性容器外和弹性项目内的一切元素都不受影响。简单地说，Flexbox 定义了弹性容器内弹性项目该如何布局

    FFC应用场景
    自动撑开剩余高度/宽度
    问题：看一个经典两栏布局：左边为侧边导航栏，右边为内容区域，用我们之前的常规布局，可能就需要使用到css的calc方法来动态计算剩余填充宽度了，但如果使用flex布局的话，只需要一个属性就能解决这个问题

### 常见的 格式化上下文有哪些
 > BFC(block 块级) IFC(inline 内联行内) FFC(flex 弹性 css3) GFC(grid 栅格 css3)
    
    总结：
    一般来说，FFC能做的事情，通过GFC都能搞定，反过来GFC能做的事通过FFC也能实现。 通常弹性布局使用FFC，二维网格布局使用GFC。
    所有的 FFC 与 GFC 也是一个 BFC，在遵循自己的规范的情况下，向下兼容 BFC 规范。

### link 和 @import 有什么区别
  - 简答
    link 是 HTML 标签；@import 是 css 语法；
    页面被加载时，link 会和 html 同时被加载；@import 在页面记载完后才被加载；
    @import 是 css2.1 才有的语法，IE5以下不支持；link 不存在兼容性问题；
    link 的样式权重高于 @import 的权重
    javaScript 只能控制 dom 去改变 link 标签引入的样式；而 @import 的样式不是 dom 可以控制的
    
### ::before 和 :after 中双冒号和单冒号有什么区别，解释一下伪元素的作用
    单冒号(:) 用于 CSS3伪类，双冒号(::)用于 CSS3 伪元素
    ::before 就是以一个子元素存在，定义在元素主体之前的一个伪元素。并不存在于 dom 之中，只存在页面之中。

    :before 和 :after 这2个伪元素，是在 CSS2.1中新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着 Web 的进化，在 CSS3 的规范里，伪元素的语法就被替换为双冒号，成为 ::before ::after

### CSS3 新增的伪类有哪些
    div:first-child —— 匹配 div 中第一个元素
    div:last-child —— 匹配 div 中最后一个元素
    div:nth-child(n) —— 匹配父元素中第n个子元素 n可以是数字、关键字、公式。
        注意:n也可以是 even（表示偶数） odd（表示奇数） n也可以是公式，从0开始
        
    div:first-of-type —— 指定类型 div 的第一个
    div:last-of-type —— 指定类型 div 的最后一个
    div:nth-of-type(n) —— 指定类型e的第n个

    div:not(div2)    //除div2之外的全部div
    :enable 选择可用表单元素
    :disable 选择禁用表单元素
    :checked 选择被选中的表单元素

### css 伪类元素
    :before —— 在元素内部的前面插入内容
    :after —— 在元素内部的后面插入内容

    值得注意的是:
        before、after 必须得有 content 属性
        before 在内容的前面，after 在内容的后面
        before 和 after 创建一个元素，都属于行内元素
        因为在 dom 里面看不见伪元素，所以称之为这类元素为 伪元素
        伪元素和标签选择器一样，权重为 1

## 性能优化
    如何利用webpack来优化前端性能？ 问的是生产环境优化
    如何提高webpack的构建速度？ 问的是构建速度的优化
### 如何利用webpack来优化前端性能？
 - 代码压缩
    - 按需加载
        * 代码分割 splitChunks - 在optimization配置项中配置
            1.可以将node__mudules中代码单独打包成一个chunk输出（比如使用了jqury？）
            2.会自动分析多入口chunk中，有没有公共的文件，如果有会打包成单独的一个chunk不会重复打包
        * 使用Dll进行分包
            1.正常情况下node_module会被打包成一个文件
            2. 使用dll技术，对可以将那些不常更新的框架和库进行单独打包，生成一个chunk
        * 使用路由懒加载
            在代码中所有被 import()函数引用的模块，都将打成一个单独的包，放在 chunk 存储的目录下。在浏览器运行到这一行代码时，就会自动请求这个资源，实现异步加载
        * 资源压缩
            js压缩:利用 terser-webpack-plugin
            css压缩:利用了optimize-css-assets-webpack-plugin 插件
            图片压缩：image-webpack-loader 插件
            commonsChunkPlugin
            删除了console、注释、空格、换行、没有使用的css代码等，其实作用很小

### 如何提高webpack的构建速度？
 - 首先使用 webpack-bundle-analyzer 构建出打包后的chunkb包查看 打包后那些文件过大
 - 减少需要构建的文件或代码
    
 - webpack4.0 带来的优化
    v8 引擎带来的优化（for of 替代 forEach、Map 和 Set 替代 Object、includes 替代 indexOf）
    默认使用更快的 md4 hash 算法
    webpack AST 可以直接从 loader 传递给 AST，减少解析时间
    使用字符串方法替代正则表达式
 - tree-shaking 删除没有使用的代码
    tree-shaking是一种基于 ES Module 规范的 Dead Code Elimination 技术打包，在打包过程中检测工程中没有引用过的模块并进行标记，删除没有引用过的模块，提高构建速度，较少程序运行时间。
    **使用tree-shaking需要注意什么？**
    * 默认mode = production ，生产环境默认开启tree-shaking功能。
    * 需要是使用 ES6 规范编写模块代码,ES6的模块依赖关系是确定的，和运行时状态无关
    * 尽量不写带有副作用的代码。如编写了立即执行函数，在函数里使用了外部变量等。

## 微前端的经验及如何搭建 qiankun.js
### 目前常见的微前端
1. 基于 iframe 完全隔离的方案
    作为前端开发，我们对 iframe 已经非常熟悉了，在一个应用中可以独立运行另一个应用。它具有显著的优点：
    优点：
        非常简单，无需任何改造
        完美隔离，JS、CSS 都是独立的运行环境
        不限制使用，页面上可以放多个 iframe 来组合业务
    缺点：
        无法保持路由状态，刷新后路由状态就丢失
        完全的隔离导致与子应用的交互变得极其困难
        iframe 中的弹窗无法突破其本身
        整个应用全量资源加载，加载太慢

2. 基于 single-spa 路由劫持方案
> 劫持路由的方式来做子应用之间的切换，但接入方式需要融合自身的路由，有一定的局限性；实现了JS沙箱、样式隔离

### qiankun.js 搭建微前端步骤
1. 主应用安装 npm i qiankun -s
2. 主应用注册微应用 registerMicroApps 之后 start()
3. 微应用不需要安装其他依赖就可接入
4. 导出相应的生命周期钩子，微应用需要在自己的入口 js (通常就是你配置的 webpack 的 entry js) 导出 bootstrap、mount、unmount 三个生命周期钩子，以供主应用在适当的时机调用
 **缺点：不支持vite**

## 通用、业务组件的经验

## 项目中遇到的问题有哪些？怎么解决
    form 表单中，只有一个输入框，按下回车键会触发页面刷新。解决：在 form 中配置 @submit.native.prevent
    new Map() 结构的数据，vue 2.0监听不到，在子组件中。解决： 存入store 保证刷新页面数据会重新 set

    vue2.0 的项目中使用 echarts 库，切换tabs 时，页面崩溃了，卡死。
        解决1：初始化 echarts 时，先清掉上一次的实例，不然浏览器占用的内存会成倍数增加。导致内存溢出。
        解决2：vue组件在beforeDestroy勾子中，最好也要清掉echarts实例，原因也是为了及时清空不必要占用的内存
    
    import a from './a.vue'; export { a,b,c } 这样的公共文件里面导出组件 a, a 在首页要用，在详情页要用。但是在先打开了首页后， 在详情也就医pain空白了。
    解决： 在详情页使用 import a from './a.vue';形式使用。因为a组件在首页加载过一次就不会在加载了，所以在详情页不加载就拿不到了。

## 其他概念

### 跨域问题的解决

### SFC
    平时写的.vue文件称为SFC，单文件组件规范。
    每个vue文件包含三种类型的顶级语言块，template，script，style。还允许添加可选的自定义块。

### 单页面与多页面的区别
    单页面应用（SPA）只有一个web页面的应用。单页面跳转仅刷新局部资源，公共资源仅需加载一次，常用与PC端官网，购物网站。
    多页面应用（MPA）多页面跳转刷新所有的资源，每个公共资源需选择性重新加载，常用与APP或客户端。
    单页面优点:用户体验好，内容改变不需要刷新整个页面。前后端分离。页面效果会比较炫酷
    单页面缺点:不利于SEO，导航不可用，需自行实现。初次加载耗时多。